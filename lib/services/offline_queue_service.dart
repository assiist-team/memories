import 'dart:async';
import 'dart:convert';
import 'package:memories/models/queued_moment.dart';
import 'package:memories/models/queue_change_event.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';

part 'offline_queue_service.g.dart'; // Will be generated by build_runner

const String _queueKey = 'queued_moments';

/// Service for managing offline queue of moments and mementos
/// 
/// Both moments and mementos are stored in the same queue since they share
/// the same save pipeline and data structure. The memory type is tracked
/// via the QueuedMoment.memoryType field.
@riverpod
OfflineQueueService offlineQueueService(OfflineQueueServiceRef ref) {
  return OfflineQueueService();
}

class OfflineQueueService {
  final _changeController = StreamController<QueueChangeEvent>.broadcast();
  
  /// Stream of queue change events
  Stream<QueueChangeEvent> get changeStream => _changeController.stream;
  
  /// Dispose resources
  void dispose() {
    _changeController.close();
  }

  /// Get all queued moments from storage
  Future<List<QueuedMoment>> _getAllMoments() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_queueKey);
    if (jsonString == null) return [];
    
    final List<dynamic> jsonList = jsonDecode(jsonString);
    return jsonList.map((json) => QueuedMoment.fromJson(json as Map<String, dynamic>)).toList();
  }

  /// Save all moments to storage
  Future<void> _saveAllMoments(List<QueuedMoment> moments) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonList = moments.map((m) => m.toJson()).toList();
    await prefs.setString(_queueKey, jsonEncode(jsonList));
  }

  /// Add a moment to the queue
  Future<void> enqueue(QueuedMoment moment) async {
    final moments = await _getAllMoments();
    final isUpdate = moments.any((m) => m.localId == moment.localId);
    // Remove if already exists (update)
    moments.removeWhere((m) => m.localId == moment.localId);
    moments.add(moment);
    await _saveAllMoments(moments);
    
    // Emit change event
    _changeController.add(QueueChangeEvent(
      localId: moment.localId,
      memoryType: moment.memoryType,
      type: isUpdate ? QueueChangeType.updated : QueueChangeType.added,
    ));
  }

  /// Get all queued moments
  Future<List<QueuedMoment>> getAllQueued() async {
    return await _getAllMoments();
  }

  /// Get queued moments by status
  Future<List<QueuedMoment>> getByStatus(String status) async {
    final moments = await _getAllMoments();
    return moments.where((moment) => moment.status == status).toList();
  }

  /// Get a specific queued moment by local ID
  Future<QueuedMoment?> getByLocalId(String localId) async {
    final moments = await _getAllMoments();
    try {
      return moments.firstWhere((m) => m.localId == localId);
    } catch (e) {
      return null;
    }
  }

  /// Update a queued moment
  Future<void> update(QueuedMoment moment) async {
    await enqueue(moment); // Same as enqueue for this implementation (emits updated event)
  }

  /// Remove a queued moment (after successful sync)
  Future<void> remove(String localId) async {
    final moments = await _getAllMoments();
    final moment = moments.firstWhere(
      (m) => m.localId == localId,
      orElse: () => throw StateError('Moment not found: $localId'),
    );
    final memoryType = moment.memoryType;
    moments.removeWhere((m) => m.localId == localId);
    await _saveAllMoments(moments);
    
    // Emit change event
    _changeController.add(QueueChangeEvent(
      localId: localId,
      memoryType: memoryType,
      type: QueueChangeType.removed,
    ));
  }

  /// Get count of queued moments
  Future<int> getCount() async {
    final moments = await _getAllMoments();
    return moments.length;
  }

  /// Get count by status
  Future<int> getCountByStatus(String status) async {
    final moments = await _getAllMoments();
    return moments.where((moment) => moment.status == status).length;
  }

  /// Generate a deterministic local ID
  static String generateLocalId() {
    return const Uuid().v4();
  }
}

